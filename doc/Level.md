Notes on code in level.cljc
===

## 

## Notation

`m*`, `m+`, `m-` are either scalar or matrix `*`, `+`, and `-`, depending on the
value of `use-core-matrix`, which determines which namespace is loaded.
`e*` is `*`, or elementwise matrix multiplication.  `tr` is matrix transpose,
or the identity function for scalars.  `inv` is reciprocal, for scalars,
or matrix inverse, for matrices.  `(make-identity-obj n)` returns an n by n 
identity matrix, or 1 for scalars.

The derivative of function `f` is called `f'` .  A value of `foo` at the next
level down is called `-foo`.  A value of `foo` at the next level up is called
`+foo`.  Also see the docstrings for ``Level`` and other functions.

The functions `next-foo` calculate the next value of `foo`.  Each `next-foo`
function accepts three `Level` structures as values: The next `Level` down,
the current `Level`, and the next `Level` up.  However, some of these `Level`s
might not be used for a given calculation, in which case the parameter
for that level will be `_` , indicating that it will be ignored.

This version of level.cljc doesn't use a function g, but assumes that g is
a product of theta with another function `h`, as in many Bogacz's
examples.


## Overview

Please see the docstring for `->Level` or `map->Level` (at the repl or
in level.cljc) for information about the fields in the `Level` record
definition.  Note that each of the data fields also has a corresponding
`-dt` field that holds the scaling factor that determines how fast the
field will be updated.  I chose to include these in each Level record to
allow for the possibility of different speeds at different levesl.

The state of a network consists of a sequence of three or more levels:
A first (zeroth) and last level, and one or more inner levels.  It's
only the inner levels that should be updated according to central
equations in Bogacz such as (53) and (54).  The first level captures
sensory input--i.e. it records the prediction error eps, which is
calculated from sensory input phi at that level, along with a function
theta h of the next level phi.  i.e. at this level, `phi` is simply
provided by the system outside of the levels, and is not calculated
from lower level prediction errors as in (53). The last level simply
provides a `phi`, which is the mean of a prior distribution at that
level.  This `phi` typically never changes. (It's genetically or
developmentally determined.) The other terms at this top level can be
ignored. Note that Bogacz's examples typically use two inner levels;
his representation captures what's called the first and last levels
here using individual parameters such as `u` and `v_p`.

Note that the code in levels.cljc is supposed to be able to work with
any number of middle levels and with either vectors and matrices, or
with scalars.  If `use-core-matrix` is true, the system will be
configured for vectors and matrices.  It should work with scalars, too,
but it will be slower than if `use-core-matrix` is false.  Currently
(9/2016), the value of `use-core-matrix` must be set in levels.cljc
before that file is loaded, but this will probably change in the future.


## Running, creating plots

See src/free/exercise_3.cljc or src/free/example_1.cljs for simple
illustrations of use of this system.  In these examples, there are three
levels, i.e. a bottom level, a middle level, and a top level (which is
not a full-fledged level; all it does is to provide the mean of the
prior distribution).  

Each of these two examples when run (when the file is loaded using `use`
or `require`), creates a variable named `stages`, which contains a
virtual sequence of states, or stages, of the cognitive system.  The
first stage contains the three levels in their initial configurations.
Subsequent stages contain updated versions of these levels.  (The top
level never changes, however.)  That is, `stages` is what's known
as a "lazy sequence" of unlimited length.  When first defined, at
most only the first or first and second elements of the sequence
exist (are "realized").  However, if you use subsequent elements,
they'll be created as needed.

You can use `plot-levels` in src/free/plots to plot the results, or
see the comment on plotting in src/free/exercise_3.cljc.

For example, at a Clojure REPL prompt, you can do this:

    (use '[free.example-1])
    ;; Note that stages has now been defined and made available.
    (use '[free.plots])
    (plot-level 0 (take 1000 stages))
    (plot-level 1 (take 1000 stages))

The last two lines will create two windows containing plots of four
values from level 0, and four from level 1, in the first 1000 stages.
(In Bogacz's exercise 3, for example, he runs his model for 5 "units of
time" (p. 4), but divides `MAXT` (= 5) by 0.01, the value of `DT`.
Since 5/0.01 = 500, this corresponds to 500 stages here.)

Note that when the first instance of `plot-level` was run above, the
first 1000 stages (numbered 0 to 999) were generated by the code built
into the lazy sequence.  The second instance just makes use of the
stages that have already been generated.  If you decide that you need to
see what happens after the thousandth stage, you can rerun the same
command with a new number passed to `take`:

    (plot-level 1 (take 2000 stages))

The first 1000 stages won't be regenerated, as they already exist.  Only
stages from 1000 to 1999 will be generated as a result of running this
command.


## Level dependencies

* `phi` at level *n* depends on `eps` at level *n* - 1.

* `eps` at level *n* depends on `phi` at level *n* + 1.

* `theta` at level *n* depends on `phi` at level *n* + 1.

* `sigma` at level *n* depends only on level *n*.


## next-level

There's an asymmetry between the bottom and top levels.  

### Bottom level: 

It's only the next `phi` that depends on the next level down from the
perspective of other levels.  since the bottom level has no next level
down, `phi` must be treated specially.  So the bottom level needs to
provide `phi`, which should usually vary as a function of things outside
the levels system.  Since it's natural to have `phi` at each level be a
variable, not the result of a function, we need to provide a special
function to generate new `phi`s on every timestep.  This is the
`next-bottom` that must be provided to `next-level`.

### Top level:

At the top of the stack, `phi` is the only variable from above that's
needed by any of the `next-` functions; it's used by `next-eps` and
`next-theta`.  If `phi` never changes (cf. Bogacz's use of `v_p` in
his answer to exercise 3), then we can just make the very top level
be a special one that contains a `phi` (and probably only `phi`) and
that isn't updated by `next-phi` or by the other `next-` functions.
